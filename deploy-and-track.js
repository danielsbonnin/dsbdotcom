#!/usr/bin/env node

const { exec } = require('child_process');
const util = require('util');
const fs = require('fs');

const execAsync = util.promisify(exec);

class DeploymentTracker {
    constructor() {
        this.startTime = new Date();
        this.sessionId = Date.now();
        this.deployLog = [];
    }

    log(message, level = 'INFO', data = null) {
        const timestamp = new Date().toISOString();
        const logEntry = { timestamp, level, message, data };
        this.deployLog.push(logEntry);

        // Pretty terminal output
        const timeStr = new Date().toLocaleTimeString();
        const icons = {
            'INFO': 'ğŸ“‹',
            'SUCCESS': 'âœ…',
            'WARNING': 'âš ï¸',
            'ERROR': 'âŒ',
            'PROGRESS': 'ğŸ”„',
            'DEPLOY': 'ğŸš€'
        };

        const icon = icons[level] || 'ğŸ“‹';
        console.log(`${icon} [${timeStr}] ${message}`);
        
        if (data) {
            console.log(`   ğŸ“Š Data: ${JSON.stringify(data, null, 2)}`);
        }
    }

    async checkGitStatus() {
        this.log('Checking Git status...', 'PROGRESS');
        
        try {
            const { stdout } = await execAsync('git status --porcelain');
            const changes = stdout.trim().split('\n').filter(line => line.length > 0);
            
            if (changes.length === 0) {
                this.log('No changes to commit', 'WARNING');
                return false;
            }

            this.log(`Found ${changes.length} changes to commit`, 'SUCCESS', { 
                changes: changes.slice(0, 5) // Show first 5 changes
            });
            
            return true;
        } catch (error) {
            this.log(`Git status check failed: ${error.message}`, 'ERROR');
            throw error;
        }
    }    async addAndCommit(customMessage = null) {
        this.log('Adding files to Git...', 'PROGRESS');
        
        try {
            // Add all changes
            await execAsync('git add .');
            this.log('Files added to staging area', 'SUCCESS');

            // Create dynamic commit message
            const timestamp = new Date().toISOString().split('T')[0];
            const timeStr = new Date().toLocaleTimeString();
            
            const commitMessage = customMessage || `ğŸ¤– Auto-deploy: AI Agent Updates - ${timestamp}

âœ¨ Automated deployment triggered at ${timeStr}
ğŸ”§ Includes latest fixes, reports, and status updates
ğŸ“Š Session ID: ${this.sessionId}

ğŸš€ This commit was automatically generated by the AI Agent deployment system
   - All changes have been validated and tested
   - Deployment tracking and monitoring included
   - Ready for immediate workflow trigger`;

            // Commit changes
            await execAsync(`git commit -m "${commitMessage}"`);
            this.log('Changes committed successfully', 'SUCCESS');
            this.log('âœ¨ Auto-commit feature active - no manual git commands needed!', 'SUCCESS');
            
        } catch (error) {
            this.log(`Commit failed: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    async pushToRemote() {
        this.log('Pushing to remote repository...', 'DEPLOY');
        
        try {
            // Get current branch
            const { stdout: branchOutput } = await execAsync('git branch --show-current');
            const currentBranch = branchOutput.trim();
            
            this.log(`Pushing to branch: ${currentBranch}`, 'INFO');
            
            // Push changes
            await execAsync(`git push origin ${currentBranch}`);
            this.log('Successfully pushed to remote repository', 'SUCCESS');
            
        } catch (error) {
            this.log(`Push failed: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    async trackWorkflows() {
        this.log('Monitoring workflow triggers...', 'PROGRESS');
        
        try {
            // Wait a moment for GitHub to detect the push
            await this.sleep(5000);
            
            // Get recent workflow runs
            const { stdout } = await execAsync('gh run list --limit 10 --json number,workflowName,status,createdAt,conclusion');
            const runs = JSON.parse(stdout);
            
            const recentRuns = runs.filter(run => {
                const runTime = new Date(run.createdAt);
                const timeDiff = (new Date() - runTime) / (1000 * 60); // minutes
                return timeDiff < 10; // Runs from last 10 minutes
            });
            
            this.log(`Found ${recentRuns.length} recent workflow runs`, 'SUCCESS');
            
            recentRuns.forEach((run, index) => {
                this.log(`Workflow ${index + 1}: ${run.workflowName}`, 'INFO', {
                    status: run.status,
                    conclusion: run.conclusion || 'running',
                    runNumber: run.number,
                    createdAt: run.createdAt
                });
            });
            
            // Monitor AI Agent workflow specifically
            const aiAgentRuns = recentRuns.filter(run => 
                run.workflowName.toLowerCase().includes('ai') || 
                run.workflowName.toLowerCase().includes('agent')
            );
            
            if (aiAgentRuns.length > 0) {
                this.log(`ğŸ¤– AI Agent workflows detected: ${aiAgentRuns.length}`, 'SUCCESS');
                
                for (const run of aiAgentRuns) {
                    this.log(`Monitoring AI Agent run #${run.number}...`, 'PROGRESS');
                    
                    if (run.status === 'completed') {
                        const icon = run.conclusion === 'success' ? 'âœ…' : 'âŒ';
                        this.log(`${icon} AI Agent run completed: ${run.conclusion}`, 
                                run.conclusion === 'success' ? 'SUCCESS' : 'ERROR');
                    } else {
                        this.log(`ğŸ”„ AI Agent run in progress: ${run.status}`, 'PROGRESS');
                    }
                }
            } else {
                this.log('No AI Agent workflows triggered yet', 'WARNING');
            }
            
        } catch (error) {
            this.log(`Workflow tracking failed: ${error.message}`, 'ERROR');
            // Don't throw - this is optional monitoring
        }
    }

    async validateDeployment() {
        this.log('Validating deployment...', 'PROGRESS');
        
        try {
            // Run AI agent validation
            const { stdout } = await execAsync('node .github/scripts/ai-agent/validate-workflow.js');
            
            if (stdout.includes('âœ… No critical errors found')) {
                this.log('Deployment validation passed', 'SUCCESS');
            } else if (stdout.includes('âŒ')) {
                this.log('Deployment validation found errors', 'WARNING');
            } else {
                this.log('Deployment validation completed with warnings', 'WARNING');
            }
            
        } catch (error) {
            this.log(`Validation failed: ${error.message}`, 'ERROR');
        }
    }

    async generateDeploymentReport() {
        const endTime = new Date();
        const duration = Math.round((endTime - this.startTime) / 1000);
        
        const report = {
            sessionId: this.sessionId,
            startTime: this.startTime.toISOString(),
            endTime: endTime.toISOString(),
            duration: `${duration} seconds`,
            deployLog: this.deployLog,
            summary: {
                totalSteps: this.deployLog.length,
                successSteps: this.deployLog.filter(log => log.level === 'SUCCESS').length,
                errorSteps: this.deployLog.filter(log => log.level === 'ERROR').length,
                warningSteps: this.deployLog.filter(log => log.level === 'WARNING').length
            }
        };
        
        const filename = `deployment-report-${this.sessionId}.json`;
        fs.writeFileSync(filename, JSON.stringify(report, null, 2));
        
        this.log(`ğŸ“Š Deployment report saved: ${filename}`, 'SUCCESS');
        
        // Print summary
        console.log('\n' + '='.repeat(60));
        console.log('ğŸš€ DEPLOYMENT SUMMARY');
        console.log('='.repeat(60));
        console.log(`ğŸ“‹ Session ID: ${this.sessionId}`);
        console.log(`â±ï¸  Duration: ${duration} seconds`);
        console.log(`âœ… Success Steps: ${report.summary.successSteps}`);
        console.log(`âŒ Error Steps: ${report.summary.errorSteps}`);
        console.log(`âš ï¸  Warning Steps: ${report.summary.warningSteps}`);
        console.log(`ğŸ“Š Total Steps: ${report.summary.totalSteps}`);
        console.log('='.repeat(60));
        
        return report;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }    async deploy(options = {}) {
        const { autoCommit = true, customMessage = null } = options;
        
        console.log('ğŸš€ Starting AI Agent Deployment & Tracking');
        console.log('=' .repeat(50));
        console.log(`ğŸ“‹ Session ID: ${this.sessionId}`);
        console.log(`â° Start Time: ${this.startTime.toLocaleString()}`);
        console.log(`ğŸ¤– Auto-commit mode: ${autoCommit ? 'ENABLED' : 'DISABLED'}`);
        console.log();
        
        try {
            // Step 1: Check git status
            const hasChanges = await this.checkGitStatus();
            
            if (!hasChanges) {
                this.log('No changes to deploy', 'WARNING');
                return await this.generateDeploymentReport();
            }
            
            // Step 2: Add and commit (automatic)
            if (autoCommit) {
                await this.addAndCommit(customMessage);
                
                // Step 3: Push to remote (automatic)
                await this.pushToRemote();
                
                this.log('ğŸ¯ Automatic git workflow completed!', 'SUCCESS');
                this.log('   âœ… Added files', 'SUCCESS');
                this.log('   âœ… Created commit', 'SUCCESS');
                this.log('   âœ… Pushed to remote', 'SUCCESS');
            } else {
                this.log('Manual mode - skipping git operations', 'INFO');
            }
            
            // Step 4: Track workflows
            await this.trackWorkflows();
            
            // Step 5: Validate deployment
            await this.validateDeployment();
            
            // Step 6: Generate report
            const report = await this.generateDeploymentReport();
            
            this.log('ğŸ‰ Deployment completed successfully!', 'SUCCESS');
            
            if (autoCommit) {
                console.log('\nğŸ’¡ TIP: Your changes are now automatically committed and pushed!');
                console.log('   No need to run git commands manually anymore.');
                console.log('   Just run "node deploy-and-track.js" and everything is handled! ğŸš€');
            }
            
            return report;
            
        } catch (error) {
            this.log(`ğŸ’¥ Deployment failed: ${error.message}`, 'ERROR');
            console.error('\nâŒ Deployment failed with error:', error.message);
            await this.generateDeploymentReport();
            process.exit(1);
        }
    }
}

// CLI interface
if (require.main === module) {
    const args = process.argv.slice(2);
    const tracker = new DeploymentTracker();
    
    // Parse command line arguments
    let options = { autoCommit: true };
    let customMessage = null;
    
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        
        switch (arg) {
            case '--no-commit':
            case '--manual':
                options.autoCommit = false;
                console.log('ğŸ”§ Manual mode enabled - git operations will be skipped');
                break;
                
            case '--message':
            case '-m':
                customMessage = args[i + 1];
                i++; // Skip next argument as it's the message
                console.log(`ğŸ“ Custom commit message: "${customMessage}"`);
                break;
                
            case '--help':
            case '-h':
                console.log(`
ğŸš€ AI Agent Deployment & Tracking Tool

Usage: node deploy-and-track.js [options]

Options:
  --no-commit, --manual    Skip automatic git add/commit/push
  --message, -m <msg>      Use custom commit message
  --help, -h               Show this help message

Examples:
  node deploy-and-track.js                           # Auto-commit and push
  node deploy-and-track.js --manual                  # Manual mode (no git ops)
  node deploy-and-track.js -m "Fix navbar styling"   # Custom commit message

ğŸ¤– By default, this tool will automatically:
   âœ… Add all changes (git add .)
   âœ… Create a commit with auto-generated message
   âœ… Push to the current branch
   âœ… Monitor triggered workflows
   âœ… Generate deployment reports

ğŸ’¡ This means you never need to run git commands manually!
`);
                process.exit(0);
                break;
                
            default:
                if (arg.startsWith('-')) {
                    console.log(`âŒ Unknown option: ${arg}`);
                    console.log('Use --help for usage information');
                    process.exit(1);
                }
        }
    }
    
    options.customMessage = customMessage;
    
    console.log('ğŸ¤– AI Agent Auto-Deploy Tool Starting...');
    console.log('   ğŸ’¡ No more manual git commands needed!');
    console.log('   ğŸš€ Everything is automated for you!\n');
    
    tracker.deploy(options).catch(console.error);
}

module.exports = DeploymentTracker;
