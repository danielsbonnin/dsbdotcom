/**
 * Creates pull request for AI implementation
 */
async function createImplementationPR({ github, context, taskData, branchName, implementationResult }) {
  try {
    // Handle both string and object inputs
    let implementation;
    if (typeof implementationResult === 'string') {
      try {
        implementation = JSON.parse(implementationResult);
      } catch (parseError) {
        console.log('Failed to parse implementationResult as JSON, treating as object:', parseError.message);
        implementation = {
          analysis: "Implementation completed",
          filesModified: 1,
          files: [],
          instructions: "Review the generated code",
          taskData: taskData,
          timestamp: new Date().toISOString()
        };
      }
    } else {
      implementation = implementationResult || {
        analysis: "Implementation completed",
        filesModified: 1,
        files: [],
        instructions: "Review the generated code", 
        taskData: taskData,
        timestamp: new Date().toISOString()
      };
    }
    
    // Create pull request
    const { data: pr } = await github.rest.pulls.create({
      owner: context.repo.owner,
      repo: context.repo.repo,
      title: `ðŸ¤– AI Implementation: ${taskData.title}`,
      head: branchName,
      base: 'main',
      body: generatePRBody(taskData, implementation)
    });

    console.log(`Created pull request #${pr.number}`);

    // Update issue with success notification
    await github.rest.issues.createComment({
      issue_number: taskData.issueNumber,
      owner: context.repo.owner,
      repo: context.repo.repo,
      body: generateSuccessNotification(pr, implementation)
    });

    // Update issue labels
    await updateIssueLabels(github, context, taskData.issueNumber);

    return pr;
    
  } catch (error) {
    console.error('Error creating pull request:', error);
    throw error;
  }
}

function generatePRBody(taskData, implementation) {
  return `## ðŸ¤– AI-Generated Implementation

This pull request contains production-ready code generated by Gemini AI.

### Original Issue
**Issue:** #${taskData.issueNumber}  
**Title:** ${taskData.title}  
**Type:** ${taskData.taskType}  
**Priority:** ${taskData.priority}

### Implementation Details
${implementation.analysis}

### Files Modified (${implementation.filesModified})
${implementation.files.map(f => `- \`${f.path}\` (${f.action}): ${f.explanation}`).join('\n')}

### Setup Instructions
${implementation.instructions}

### Review Checklist
- [ ] **Code Quality** - Review AI-generated implementation
- [ ] **Functionality** - Test the implementation locally
- [ ] **Requirements** - Verify all issue requirements are met
- [ ] **Design** - Check responsive design and accessibility
- [ ] **Performance** - Ensure no performance regressions

### AI Analysis
See \`AI_IMPLEMENTATION.md\` for complete analysis and technical details.

---
**AI Model:** Gemini 1.5 Flash  
**Generated:** ${implementation.timestamp}

Closes #${taskData.issueNumber}`;
}

function generateSuccessNotification(pr, implementation) {
  return `âœ… **AI Implementation Complete!**

ðŸš€ **Pull Request:** #${pr.number}

The AI agent has successfully analyzed your request and generated working code.

### What was implemented:
- ${implementation.filesModified} files created/modified
- Production-ready TypeScript/React code
- Responsive design with Tailwind CSS
- Complete implementation (no placeholders)

### Generated Files:
${implementation.files.slice(0, 5).map(f => `- \`${f.path}\``).join('\n')}
${implementation.files.length > 5 ? `- *...and ${implementation.files.length - 5} more files*` : ''}

### Next Steps:
1. ðŸ“‹ Review the pull request and code quality
2. ðŸ§ª Test the implementation locally if needed  
3. âœ… Merge when satisfied with the results
4. ðŸš€ Changes will be automatically deployed

The implementation is ready for production use! ðŸŽ‰

**âš¡ Quick Actions:**
- [View Pull Request](#${pr.number})
- [Review Code Changes](${pr.html_url}/files)
- [Test Implementation](${pr.html_url})`;
}

async function updateIssueLabels(github, context, issueNumber) {
  try {
    // Add success labels
    await github.rest.issues.addLabels({
      issue_number: issueNumber,
      owner: context.repo.owner,
      repo: context.repo.repo,
      labels: ['ai-implemented', 'ready-for-review']
    });

    // Remove working labels
    const labelsToRemove = ['ai-working', 'in-progress'];
    
    for (const label of labelsToRemove) {
      try {
        await github.rest.issues.removeLabel({
          issue_number: issueNumber,
          owner: context.repo.owner,
          repo: context.repo.repo,
          name: label
        });
      } catch (error) {
        // Ignore if label doesn't exist
        console.log(`Label '${label}' not found on issue, skipping removal`);
      }
    }
    
  } catch (error) {
    console.error('Error updating issue labels:', error);
    // Don't fail the entire process for label updates
  }
}

module.exports = { createImplementationPR };
